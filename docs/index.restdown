---
title: Mackerel
markdown2extras: wiki-tables, code-friendly
apisections:
---

# Mackerel

Metering and usage reports for Manta.

# Overview

Metering reports are generated by running Marlin jobs. The smallest granularity
metering runs at is hourly. Daily reports are generated from hourly reports, and
monthly reports are generated from daily reports.

There are three classes of usage that Mackerel meters:

* Storage: bytes stored on disk, number of keys, number of objects
* Request: request totals by method, total transfer (bandwidth) in and out
* Compute: wall time spent categorized by DRAM, bandwidth in and out

Important notes:

* Customers are metered for the object and key when linking to an object they do
  not own.
* Daily and monthly storage metering is **summed** from hourly and daily
  reports, respectively. Since each hourly report is a snapshot of usage at
  that hour, daily and monthly reports are in **unit-hours** of usage (e.g.
  byte-hours).
* Requests count toward usage for the owner of the Manta object, not the caller
  of the request.
* Compute is measured in **wall time** (not CPU time).

# Record Format

All records are stored in newline-separated JSON format. The sample records
below represent a single record, formatted with indentation.

## Storage

Directory count, key count, unique object count, total bytes. Categorized by
namespace.

An object that is pointed to by two keys in different namespaces will be
counted under a namespace in this order: `/stor`, `/public`, `/jobs`,
`/reports`.  Each namespace will appear in the record even if there is no usage
for that namespace.

    {
         "owner": "cc56f978-00a7-4908-8d20-9580a3f60a6",
         "stor": {
             "namespace": "stor",
             "directories": 111,
             "keys": 234,
             "objects": 184,
             "bytes": 348582
         },
         "public": {
             "namespace": "public",
             "directories": 2,
             "keys": 5,
             "objects": 5,
             "bytes": 2235
         },
         "jobs": {
             "namespace": "jobs",
             "directories": 0,
             "keys": 0,
             "objects": 0,
             "bytes": 0
         },
         "reports": {
             "namespace": "reports",
             "directories": 6,
             "keys": 7,
             "objects": 9,
             "bytes": 12592
         }
    }

## Request

Request count categorized by method. Bandwidth in bytes, separated by bandwidth
in, bandwidth out, total header size in, total header size out.

Each method of `OPTION`, `GET`, `HEAD`, `POST`, `PUT` and `DELETE` are included
even if there were no requests of that method. `TRACE` and `CONNECT` are never
used, and are not included.

    {
        "owner": "eba7f07c-d57c-48f6-8072-f75db963e9d6",
        "requests": {
            "OPTION": 0,
            "GET": 2,
            "HEAD": 0,
            "POST": 0,
            "PUT": 1,
            "DELETE": 0
        },
        "bandwidth": {
            "in": 6880413,
            "out": 0,
            "headerIn": 2274,
            "headerOut": 714
        }
    }


## Compute

Wall time in [seconds, nanoseconds] categorized by zone memory (in bytes),
bandwidth in bytes.

The `time` section only includes memory levels for which the owner spent
time in a zone of that size (i.e. it does not include all possible memory
levels). Bandwidth includes all bytes seen by the vnic of the zone. This
includes any Marlin overhead.

    {
        "owner": "59159a6e-51b5-4e27-bca4-6cd9c8626eb2",
        "time": {
            "268435456": [
                1316,
                463384821
            ],
            "536870912": [
                60,
                110549076
            ],
            "2147483648": [
                6,
                237815959
            ]
        },
        "bandwidth": {
            "in": 223248,
            "out": 17610
        }
    }

# Implementation

## Storage

Daily storage metering sums up the usage from every hour on the given calendar
day, and monthly storage metering sums up the usage from every day on the given
calendar month.  This means daily and monthly storage metering represent
**unit-hours** of usage (i.e., byte-hours, key-count-hours).

Storage hourly metering consists of a map phase three reduce phases.

Storage raw data consists of postgres dumps of each moray shard in JSON format.
The first line contains the table name and describes the schema for each entry
(pretty-printed here):

    {
      "name": "manta",
      "keys": [
        "_id",
        "_txn_snap",
        "_key",
        "_value",
        "_etag",
        "_mtime",
        "dirname",
        "owner",
        "objectid",
        "type"
      ]
    }

Following that are rows in JSON format with arrays of values that correspond to
the schema from the first line.

    {
      "entry": [
        "58",
        "\\N",
        "/cc56f978-00a7-4908-8d20-9580a3f60a6e/stor/logs/postgresql/2012/11/12/18/49366a2c.log.bz2",
        "{
             \"dirname\":\"/cc56f978-00a7-4908-8d20-9580a3f60a6e/stor/logs/postgresql/2012/11/12/18\",
             \"key\":\"/cc56f978-00a7-4908-8d20-9580a3f60a6e/stor/logs/postgresql/2012/11/12/18/49366a2c.log.bz2\",
             \"headers\":{},
             \"mtime\":1352746869592,
             \"owner\":\"cc56f978-00a7-4908-8d20-9580a3f60a6e\",
             \"type\":\"object\",
             \"contentLength\":84939,
             \"contentMD5\":\"iSdRMW7Irsw1UwYoRDFmIA==\",
             \"contentType\":\"application/x-bzip2\",
             \"etag\":\"5fcc0345-1044-4b67-b7e8-98ee692001bc\",
             \"objectId\":\"5fcc0345-1044-4b67-b7e8-98ee692001bc\",
             \"sharks\":[{
                 \"availableMB\":20477,
                 \"percentUsed\":1,
                 \"datacenter\":\"bh1-kvm1\",
                 \"server_uuid\":\"44454c4c-4700-1034-804a-c7c04f354d31\",
                 \"zone_uuid\":\"ef8b166a-ac3e-4d59-bb73-a65e2b17ba44\",
                 \"url\":\"http://ef8b166a-ac3e-4d59-bb73-a65e2b17ba44.stor.bh1-kvm1.joyent.us\"
             }, {
                 \"availableMB\":20477,
                 \"percentUsed\":1,
                 \"datacenter\":\"bh1-kvm1\",
                 \"server_uuid\":\"44454c4c-4700-1034-804a-c7c04f354d31\",
                 \"zone_uuid\":\"59fb8bd3-67a7-4da2-bb68-287e2db01ec1\",
                 \"url\":\"http://59fb8bd3-67a7-4da2-bb68-287e2db01ec1.stor.bh1-kvm1.joyent.us\"
             }]
         }",
        "6C4D4587",
        "1352746869598",
        "/cc56f978-00a7-4908-8d20-9580a3f60a6e/stor/logs/postgresql/2012/11/12/18",
        "cc56f978-00a7-4908-8d20-9580a3f60a6e",
        "5fcc0345-1044-4b67-b7e8-98ee692001bc",
        "object"
      ]
    }

The map phase takes extracts the `_value` field and emits it as output. These
records are partitioned and sent to reducers by owner, type, and objectId such
that all keys that point to the same object for a single owner are colocated on
a reducer. Note that with cross-account links, both users will be charged
for the same object, even if no extra disk space is being used. Cardinality of
data is the number of keys in Manta.

The first reduce phase deduplicates any keys that point to the same object and
aggregates usage per owner by namespace.  ObjectIds are indexed in-memory and
any keys that point to the same object only increment a user's number of keys.
Once aggregation is finished, one record is emitted per owner per namespace
partitioned to that reducer.

    {
         "owner": "cc56f978-00a7-4908-8d20-9580a3f60a6e",
         "namespace": "stor",
         "directories": 2,
         "keys": 19,
         "objects": 10,
         "bytes": 59393
    }

These results are partitioned and sent to reducers based on owner and
namespace. Cardinality of data is on the order of number of users * number of
namespaces.

The second reduce phase sums up all of a user's usage for a single namespace.
The output format is the same as the output format of the first reduce phase.

    {
         "owner": "cc56f978-00a7-4908-8d20-9580a3f60a6e",
         "namespace": "stor",
         "directories": 111,
         "keys": 234,
         "objects": 184,
         "bytes": 348582
    }

Results are partitioned by owner. Cardinality of data is number of users *
number of namespaces.

The third reduce phase combines a usage across different namespaces for a single
user into a single JSON record. If a user has no usage for a namespace, zero
usage is added to the record for that namespace at this time.

    {
         "owner": cc56f978-00a7-4908-8d20-9580a3f60a6,
         "stor": {
             "namespace": "stor",
             "directories": 111,
             "keys": 234,
             "objects": 184,
             "bytes": 348582
         },
         "public": {
             "namespace": "public",
             "directories": 2,
             "keys": 5,
             "objects": 5,
             "bytes": 2235
         },
         "reports": {
             "namespace": "reports",
             "directories": 6,
             "keys": 7,
             "objects": 9,
             "bytes": 12592
         },
         "jobs": {
             "namespace": "jobs",
             "directories": 0,
             "keys": 0,
             "objects": 0,
             "bytes": 0
         }
    }

Then, all results are sent to a final reduce phase where reports are delivered
to each user's reports namespace. See Deliver Usage.

## Request

Daily request metering sums up the usage from every hour on the given calendar
day, and monthly request metering sums up the usage from every day on the given
calendar month. This means daily and monthly request reports

Request hourly metering consists of a map phase and a reduce phase.

Request raw data consists of webapi audit logs in bunyan format (formatted as
JSON here).

    {
      "name": "audit",
      "hostname": "fb07e9ec-5137-418e-aff2-01d00aff1a49",
      "pid": 4400,
      "audit": true,
      "level": 30,
      "remoteAddress": "10.2.201.70",
      "remotePort": 36387,
      "reqHeaderLength": 818,
      "req": {
    "method": "PUT",
    "url": "/poseidon/stor/graphs/assets/manowar.tar.gz",
    "headers": {
      "accept": "application/json",
      "content-length": "6880413",
      ...
    },
    "httpVersion": "1.1",
    "trailers": {},
    "owner": "eba7f07c-d57c-48f6-8072-f75db963e9d6"
      },
      "resHeaderLength": 241,
      "res": {
    "statusCode": 204,
    "headers": {
      "etag": "d5c7ee35-e232-4bb9-b239-1ef93daffcaf",
      "last-modified": "Wed, 28 Nov 2012 21:46:00 GMT",
      ...
    },
    "trailer": false
      },
      "latency": 212,
      "_audit": true,
      "msg": "handled: 204",
      "time": "2012-11-28T21:46:00.933Z",
      "v": 0
    }

The map phase extracts fields needed for metering and does some
pre-aggregation.  Mackerel meters total requests by method (GET, PUT, DELETE,
etc), transfer in via PUT requests, transfer out via GET requests and bandwidth
used transferring headers.

    {
        "owner": "eba7f07c-d57c-48f6-8072-f75db963e9d6",
        "requests": {
            "OPTION": 0,
            "GET": 2,
            "HEAD": 0,
            "POST": 0,
            "PUT": 1,
            "DELETE": 0
        },
        "bandwidth": {
            "in": 6880413,
            "out": 0,
            "headerIn": 2274,
            "headerOut": 714
        }
    }

These results are partitioned such that all of a single owner's requests are on
a single reduce node.

The reduce phase aggregates all of a user's requests. Then, all results are
sent to a final reduce phase where reports are delivered to each user's reports
namespace. See Deliver Usage.

## Compute

Compute metering uses the metering library provided by marlin to aggregate
records by owner and task. Then total wall time is aggregated based on each
task's memory level.

For more information about how compute metering works, see the [marlin
metering docs](https://mo.joyent.com/docs/marlin/master/#compute-metering).


## Deliver Usage

The last phase in hourly metering jobs is a reduce phase that

1. collates output from all the reducers in the previous phase,
2. adds any users with no usage to the usage report,
3. translates UUID to login, and
4. delivers each user's report to the user's /:login/reports directory.

In order to do add users with no usage and translate UUIDs to login, an asset
is generated and uploaded before each job that contains a mapping of all users'
UUIDs to their logins. This cache of translations may be outdated by the time
the job finishes. A cache miss should only happen if a new user was added since
the job started.
