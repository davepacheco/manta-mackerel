#!/usr/node/bin/node
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */

/*
 * Copyright (c) 2015, Joyent, Inc.
 */

/*
 * Summarize Map
 *
 * Takes as input the reports generated by the request, compute and storage
 * metering jobs, then filters some fields out and condenses other fields in
 * each record. There is one output record per input record.
 */

var Big = require('big.js');
var Transform = require('stream').Transform;
var dashdash = require('dashdash');
var lstream = require('lstream');
var util = require('util');


function stringify(key, value) {
    if (value instanceof Big) {
        return (value.toString());
    }
    return (value);
}

function SummarizeMapStream(opts) {
    this.billingTable = opts.billingTable;
    this.excludeUnapproved = opts.excludeUnapproved;
    this.log = opts.log;
    this.lookup = opts.lookup;

    this.lineNumber = 0;
    opts.decodeStrings = false;
    Transform.call(this, opts);
}
util.inherits(SummarizeMapStream, Transform);


SummarizeMapStream.prototype._transform = function _transform(line, enc, cb) {
    this.lineNumber++;

    var record;
    try {
        record = JSON.parse(line, function (key, value) {
            if (key === '') {
                return (value);
            }
            if (typeof (value) === 'string') {
                try {
                    return (new Big(value));
                } catch (e) {
                    return (value);
                }
            }
            return (value);
        });
    } catch (e) {
        this.log.error({
            error: e,
            lineNumber: this.lineNumber,
            line: line
        }, 'error parsing line ' + this.lineNumber);

        cb(e);
        return;
    }

    if (this.excludeUnapproved) {
        if (!this.lookup[record.owner]) {
            this.log.warn({record: record}, 'No login found for %s', record.owner);
        }

        if (!this.lookup[record.owner].approved) {
            this.log.debug({record: record},
                '%s not approved for provisioning. Skipping...', record.owner);
            cb();
            return;
        }
    }

    var summary;

    if (typeof (record.storage) !== 'undefined') {
        summary = this._summarizeStorage(record);
    } else if (typeof (record.requests) !== 'undefined') {
        summary = this._summarizeRequest(record);
    } else if (typeof (record.jobs) !== 'undefined') {
        summary = this._summarizeCompute(record);
    }

    this.push(JSON.stringify(summary, stringify) + '\n');
    cb();
    return;
};

SummarizeMapStream.prototype._summarizeStorage = function storage(record) {
    var bytes = new Big(0);
    Object.keys(record.storage).forEach(function (n) {
        bytes = bytes.plus(record.storage[n].bytes);
    });
    return ({
        owner: record.owner,
        byteHrs: bytes
    });
};

SummarizeMapStream.prototype._summarizeRequest = function request(record) {
    return ({
        owner: record.owner,
        requests: record.requests.type,
        bandwidth: {
            in: record.requests.bandwidth.in,
            out: record.requests.bandwidth.out
        }
    });
};

SummarizeMapStream.prototype._summarizeCompute = function compute(record) {
    var self = this;
    var jobs = record.jobs;
    var gbSeconds = 0;
    var bwin = new Big(0);
    var bwout = new Big(0);

    Object.keys(jobs).forEach(function (job) {
        var memoryGB;
        var seconds;
        Object.keys(jobs[job]).forEach(function (p) {
            memoryGB = self.billingLookup(jobs[job][p]) / 1024;
            seconds = jobs[job][p].seconds;
            bwin = bwin.plus(jobs[job][p].bandwidth.in);
            bwout = bwout.plus(jobs[job][p].bandwidth.out);
            gbSeconds += (seconds * memoryGB);
        });
    });

    return ({
        owner: record.owner,
        computeGBSeconds: gbSeconds,
        computeBandwidth: {
            in: bwin,
            out: bwout
        }
    });
};


SummarizeMapStream.prototype._billingLookup = function billingLookup(usage) {
    var self = this;
    var i;
    for (i = 0; i < self.billingTable.length; i++) {
        if (usage.disk > self.billingTable[i].disk ||
            usage.memory > self.billingTable[i].memory) {
            continue;
        } else {
            break;
        }
    }
    return (self.billingTable[i].memory);
};

function main() {
    var log = require('bunyan').createLogger({
        name: 'summarize-map.js',
        stream: process.stderr,
        level: process.env.LOG_LEVEL || 'info'
    });

    var options = [
        {
            name: 'billingTable',
            type: 'string',
            env: 'BILLING_TABLE',
            help: 'Path to the billing compute table',
            default: '../etc/billingComputeTable.json'
        },
        {
            name: 'excludeUnapproved',
            type: 'bool',
            env: 'EXCLUDE_UNAPPROVED_USERS',
            help: 'Exclude usage for users that have ' +
                    'approved_for_provisioning = false'
        },
        {
            name: 'lookupPath',
            type: 'string',
            env: 'LOOKUP_PATH',
            default: '../etc/lookup.json',
            help: 'Path to lookup file'
        },
        {
            names: ['help', 'h'],
            type: 'bool',
            help: 'Print help'
        }
    ];

    var parser = dashdash.createParser({options: options});
    var opts;
    try {
        opts = parser.parse(process.argv);
    } catch (e) {
        console.error('summarize-map: error: %s', e.message);
        process.exit(1);
    }

    if (opts.help) {
        var help = parser.help({includeEnv: true}).trimRight();
        console.log('usage: node summarize-map.js [OPTIONS]\n' +
                    'options:\n' +
                    help);
        process.exit(0);
    }

    if (opts.hasOwnProperty('excludeUnapproved') &&
        !opts.hasOwnProperty('lookupPath')) {
        console.error('summarize-map: error: missing lookup file');
        process.exit(1);
    }

    var lookup;
    if (opts.excludeUnapproved) {
        lookup = require(opts.lookupPath);
    }
    var billingTable = require(opts.billingTable).billingTable;

    var mapStream = new SummarizeMapStream({
        billingTable: billingTable,
        excludeUnapproved: opts.excludeUnapproved,
        log: log,
        lookup: lookup
    });

    mapStream.once('error', function (error) {
        log.error({error: error}, 'summarize map error');
        process.abort();
    });

    process.stdin.pipe(new lstream()).pipe(mapStream).pipe(process.stdout);
}


if (require.main === module) {
    main();
}

module.exports = SummarizeMapStream;
